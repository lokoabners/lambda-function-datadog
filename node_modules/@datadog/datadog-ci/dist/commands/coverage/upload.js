"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UploadCodeCoverageReportCommand = void 0;
const os_1 = __importDefault(require("os"));
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const t = __importStar(require("typanion"));
const upath_1 = __importDefault(require("upath"));
const constants_1 = require("../../constants");
const ci_1 = require("../../helpers/ci");
const env_1 = require("../../helpers/env");
const file_finder_1 = require("../../helpers/file-finder");
const fips_1 = require("../../helpers/fips");
const format_git_span_data_1 = require("../../helpers/git/format-git-span-data");
const glob_1 = require("../../helpers/glob");
const logger_1 = require("../../helpers/logger");
const retry_1 = require("../../helpers/retry");
const tags_1 = require("../../helpers/tags");
const user_provided_git_1 = require("../../helpers/user-provided-git");
const git_1 = require("../git-metadata/git");
const api_1 = require("./api");
const renderer_1 = require("./renderer");
const utils_1 = require("./utils");
const errorCodesStopUpload = [400, 403];
const MAX_REPORTS_PER_REQUEST = 8; // backend supports 10 attachments, to keep the logic simple we subtract 2: for PR diff and commit diff
const isCoverageReport = (file) => {
    if (upath_1.default.extname(file) !== '.xml') {
        return false;
    }
    const filename = upath_1.default.basename(file);
    return (filename.startsWith('jacoco') || filename.includes('Jacoco') // jacoco*.xml, *Jacoco*.xml
    );
};
const validateReport = (explicitFormat, file) => {
    const format = explicitFormat || (0, utils_1.detectFormat)(file);
    if (format === undefined) {
        return `Could not detect format of ${file}, please specify the format manually using the --format option`;
    }
    return (0, utils_1.validateCoverageReport)(file, format);
};
class UploadCodeCoverageReportCommand extends clipanion_1.Command {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.basePaths = clipanion_1.Option.Rest({ required: 1 });
        this.verbose = clipanion_1.Option.Boolean('--verbose', false);
        this.dryRun = clipanion_1.Option.Boolean('--dry-run', false);
        this.measures = clipanion_1.Option.Array('--measures');
        this.tags = clipanion_1.Option.Array('--tags');
        this.format = clipanion_1.Option.String('--format');
        this.uploadGitDiff = clipanion_1.Option.Boolean('--upload-git-diff', true);
        this.automaticReportsDiscovery = clipanion_1.Option.String('--auto-discovery', 'true', {
            validator: t.isBoolean(),
            tolerateBoolean: true,
        });
        this.ignoredPaths = clipanion_1.Option.String('--ignored-paths');
        this.fips = clipanion_1.Option.Boolean('--fips', false);
        this.fipsIgnoreError = clipanion_1.Option.Boolean('--fips-ignore-error', false);
        this.config = {
            apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
            env: process.env.DD_ENV,
            envVarTags: process.env.DD_TAGS,
            envVarMeasures: process.env.DD_MEASURES,
            fips: (_a = (0, env_1.toBoolean)(process.env[constants_1.FIPS_ENV_VAR])) !== null && _a !== void 0 ? _a : false,
            fipsIgnoreError: (_b = (0, env_1.toBoolean)(process.env[constants_1.FIPS_IGNORE_ERROR_ENV_VAR])) !== null && _b !== void 0 ? _b : false,
        };
        this.logger = new logger_1.Logger((s) => this.context.stdout.write(s), logger_1.LogLevel.INFO);
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            (0, fips_1.enableFips)(this.fips || this.config.fips, this.fipsIgnoreError || this.config.fipsIgnoreError);
            this.logger.setLogLevel(this.verbose ? logger_1.LogLevel.DEBUG : logger_1.LogLevel.INFO);
            this.logger.setShouldIncludeTime(this.verbose);
            if (!this.basePaths.length) {
                this.context.stderr.write('Positional arguments must be provided\n');
                return 1;
            }
            yield this.uploadCodeCoverageReports();
            if (!this.dryRun) {
                this.context.stdout.write((0, renderer_1.renderSuccessfulUploadCommand)());
            }
        });
    }
    uploadCodeCoverageReports() {
        return __awaiter(this, void 0, void 0, function* () {
            // Normalizing the basePath to resolve .. and .
            this.basePaths = this.basePaths.map((basePath) => upath_1.default.normalize(basePath));
            this.logger.info((0, renderer_1.renderCommandInfo)(this.basePaths, this.dryRun));
            const api = this.getApiHelper();
            const payloads = yield this.generatePayloads();
            let fileCount = 0;
            const initialTime = new Date().getTime();
            for (const payload of payloads) {
                fileCount += payload.paths.length;
                yield this.uploadCodeCoverageReport(api, payload);
            }
            const totalTimeSeconds = (Date.now() - initialTime) / 1000;
            this.logger.info((0, renderer_1.renderSuccessfulUpload)(this.dryRun, fileCount, totalTimeSeconds));
        });
    }
    getApiHelper() {
        if (!this.config.apiKey) {
            this.logger.error(`Neither ${chalk_1.default.red.bold('DATADOG_API_KEY')} nor ${chalk_1.default.red.bold('DD_API_KEY')} is in your environment.`);
            throw new Error('API key is missing');
        }
        return (0, api_1.apiConstructor)(api_1.intakeUrl, this.config.apiKey);
    }
    generatePayloads() {
        return __awaiter(this, void 0, void 0, function* () {
            const spanTags = yield this.getSpanTags();
            const customTags = this.getCustomTags();
            const customMeasures = this.getCustomMeasures();
            if (!!customTags['resolved']) {
                throw new Error('"resolved" is a reserved tag name, please avoid using it in your custom tags');
            }
            const commitDiff = yield this.getCommitDiff(spanTags);
            const prDiff = yield this.getPrDiff(spanTags);
            const reports = this.getMatchingCoverageReportFilesByFormat();
            let payloads = [];
            if (Object.keys(reports).length) {
                payloads = Object.entries(reports).flatMap(([format, paths]) => {
                    const numChunks = Math.ceil(paths.length / MAX_REPORTS_PER_REQUEST);
                    return Array.from({ length: numChunks }, (_, i) => ({
                        format,
                        paths: paths.slice(i * MAX_REPORTS_PER_REQUEST, (i + 1) * MAX_REPORTS_PER_REQUEST),
                        spanTags,
                        customTags,
                        customMeasures,
                        hostname: os_1.default.hostname(),
                        commitDiff,
                        prDiff,
                    }));
                });
            }
            return payloads;
        });
    }
    getPrDiff(spanTags) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.uploadGitDiff) {
                return undefined;
            }
            const baseCommit = spanTags[tags_1.GIT_PULL_REQUEST_BASE_BRANCH_SHA];
            const headCommit = spanTags[tags_1.GIT_HEAD_SHA] || spanTags[tags_1.GIT_SHA];
            if (!baseCommit || !headCommit) {
                return undefined;
            }
            try {
                const git = yield (0, git_1.newSimpleGit)();
                return yield (0, git_1.getGitDiff)(git, baseCommit, headCommit);
            }
            catch (e) {
                this.logger.debug(`Error while trying to calculate PR diff: ${e}`);
                return undefined;
            }
        });
    }
    getCommitDiff(spanTags) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.uploadGitDiff) {
                return undefined;
            }
            const commit = spanTags[tags_1.GIT_HEAD_SHA] || spanTags[tags_1.GIT_SHA];
            if (!commit) {
                return undefined;
            }
            try {
                const git = yield (0, git_1.newSimpleGit)();
                return yield (0, git_1.getGitDiff)(git, commit + '^', commit);
            }
            catch (e) {
                this.logger.debug(`Error while trying to calculate commit diff: ${e}`);
                return undefined;
            }
        });
    }
    getSpanTags() {
        return __awaiter(this, void 0, void 0, function* () {
            const ciSpanTags = (0, ci_1.getCISpanTags)();
            const gitSpanTags = yield (0, format_git_span_data_1.getGitMetadata)();
            const userGitSpanTags = (0, user_provided_git_1.getUserGitSpanTags)();
            const spanTags = Object.assign(Object.assign(Object.assign(Object.assign({}, gitSpanTags), ciSpanTags), userGitSpanTags), (this.config.env ? { env: this.config.env } : {}));
            if (!spanTags[tags_1.GIT_REPOSITORY_URL]) {
                throw new Error('git repository URL is missing');
            }
            if (!spanTags[tags_1.GIT_SHA]) {
                throw new Error('git commit SHA is missing');
            }
            return spanTags;
        });
    }
    getCustomTags() {
        const envVarTags = this.config.envVarTags ? (0, tags_1.parseTags)(this.config.envVarTags.split(',')) : {};
        const cliTags = this.tags ? (0, tags_1.parseTags)(this.tags) : {};
        return Object.assign(Object.assign({}, cliTags), envVarTags);
    }
    getCustomMeasures() {
        const envVarMeasures = this.config.envVarMeasures ? (0, tags_1.parseMetrics)(this.config.envVarMeasures.split(',')) : {};
        const cliMeasures = this.measures ? (0, tags_1.parseMetrics)(this.measures) : {};
        return Object.assign(Object.assign({}, cliMeasures), envVarMeasures);
    }
    getMatchingCoverageReportFilesByFormat() {
        const validUniqueFiles = (0, file_finder_1.findFiles)(this.basePaths || ['.'], this.automaticReportsDiscovery, (0, glob_1.parsePathsList)(this.ignoredPaths), isCoverageReport, (filePath) => validateReport(this.format, filePath), (filePath, errorMessage) => this.context.stdout.write((0, renderer_1.renderInvalidFile)(filePath, errorMessage)));
        const pathsByFormat = {};
        for (const file of validUniqueFiles) {
            const format = this.format || (0, utils_1.detectFormat)(file);
            if (format === undefined) {
                // should not be possible, such files will fail validation
                continue;
            }
            pathsByFormat[format] = pathsByFormat[format] || [];
            pathsByFormat[format].push(file);
        }
        return pathsByFormat;
    }
    uploadCodeCoverageReport(api, codeCoverageReport) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.dryRun) {
                this.logger.info((0, renderer_1.renderDryRunUpload)(codeCoverageReport));
                return;
            }
            try {
                this.logger.info((0, renderer_1.renderUpload)(codeCoverageReport));
                yield (0, retry_1.retryRequest)(() => api.uploadCodeCoverageReport(codeCoverageReport), {
                    onRetry: (e, attempt) => {
                        this.context.stderr.write((0, renderer_1.renderRetriedUpload)(codeCoverageReport, e.message, attempt));
                    },
                    retries: 5,
                });
            }
            catch (error) {
                this.context.stderr.write((0, renderer_1.renderFailedUpload)(codeCoverageReport, error));
                if (error.response) {
                    // If it's an axios error
                    if (!errorCodesStopUpload.includes(error.response.status)) {
                        // And a status code that should not stop the whole upload, just return
                        return;
                    }
                }
                throw error;
            }
        });
    }
}
exports.UploadCodeCoverageReportCommand = UploadCodeCoverageReportCommand;
UploadCodeCoverageReportCommand.paths = [['coverage', 'upload']];
UploadCodeCoverageReportCommand.usage = clipanion_1.Command.Usage({
    category: 'CI Visibility',
    description: 'Upload code coverage reports files to Datadog.',
    details: `
      This command will upload code coverage report files to Datadog.\n
      See README for details.
    `,
    examples: [
        ['Upload all code coverage report files in current directory and its subfolders', 'datadog-ci coverage upload .'],
        [
            'Upload all code coverage report files in current directory and its subfolders, ignoring src/ignored-module-a and src/ignored-module-b',
            'datadog-ci coverage upload --ignored-paths src/ignored-module-a,src/ignored-module-b .',
        ],
        [
            'Upload all code coverage report files in src/unit-test-coverage and src/acceptance-test-coverage',
            'datadog-ci coverage upload src/unit-test-coverage src/acceptance-test-coverage',
        ],
        [
            'Upload all code coverage report files in current directory and add extra tags globally',
            'datadog-ci coverage upload --tags key1:value1 --tags key2:value2 .',
        ],
        [
            'Upload all code coverage report files in current directory and add extra measures globally',
            'datadog-ci coverage upload --measures key1:123 --measures key2:321 .',
        ],
        [
            'Upload all code coverage report files in current directory to the datadoghq.eu site',
            'DD_SITE=datadoghq.eu datadog-ci coverage upload .',
        ],
        [
            'Upload all code coverage report files in current directory with extra verbosity',
            'datadog-ci coverage upload --verbose .',
        ],
    ],
});
//# sourceMappingURL=upload.js.map