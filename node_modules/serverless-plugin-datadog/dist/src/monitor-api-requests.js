"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRecommendedMonitorServerlessId = exports.getRecommendedMonitors = exports.getExistingMonitors = exports.getCloudFormationStackId = exports.searchMonitors = exports.deleteMonitor = exports.updateMonitor = exports.createMonitor = exports.InvalidAuthenticationError = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const monitors_1 = require("./monitors");
class InvalidAuthenticationError extends Error {
    constructor(message) {
        super(...message);
        this.name = "Invalid Authentication Error";
        this.message = message;
    }
}
exports.InvalidAuthenticationError = InvalidAuthenticationError;
function createMonitor(site, monitorParams, monitorsApiKey, monitorsAppKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, node_fetch_1.default)(`https://api.${site}/api/v1/monitor`, {
            method: "POST",
            headers: {
                "DD-API-KEY": monitorsApiKey,
                "DD-APPLICATION-KEY": monitorsAppKey,
                "Content-Type": "application/json",
            },
            body: JSON.stringify(monitorParams),
        });
        return response;
    });
}
exports.createMonitor = createMonitor;
function updateMonitor(site, monitorId, monitorParams, monitorsApiKey, monitorsAppKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, node_fetch_1.default)(`https://api.${site}/api/v1/monitor/${monitorId}`, {
            method: "PUT",
            headers: {
                "DD-API-KEY": monitorsApiKey,
                "DD-APPLICATION-KEY": monitorsAppKey,
                "Content-Type": "application/json",
            },
            body: JSON.stringify(monitorParams),
        });
        return response;
    });
}
exports.updateMonitor = updateMonitor;
function deleteMonitor(site, monitorId, monitorsApiKey, monitorsAppKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, node_fetch_1.default)(`https://api.${site}/api/v1/monitor/${monitorId}`, {
            method: "DELETE",
            headers: {
                "DD-API-KEY": monitorsApiKey,
                "DD-APPLICATION-KEY": monitorsAppKey,
                "Content-Type": "application/json",
            },
        });
        return response;
    });
}
exports.deleteMonitor = deleteMonitor;
function searchMonitors(site, queryTag, monitorsApiKey, monitorsAppKey) {
    return __awaiter(this, void 0, void 0, function* () {
        let monitors = [];
        let page = 0;
        let pageCount = 1;
        do {
            const query = `tag:"${queryTag}"`;
            const response = yield (0, node_fetch_1.default)(`https://api.${site}/api/v1/monitor/search?query=${query}&page=${page}`, {
                method: "GET",
                headers: {
                    "DD-API-KEY": monitorsApiKey,
                    "DD-APPLICATION-KEY": monitorsAppKey,
                    "Content-Type": "application/json",
                },
            });
            if (response.status !== 200) {
                throw new Error(`Can't fetch monitors. Status code: ${response.status}. Message: ${response.statusText}`);
            }
            const json = yield response.json();
            monitors = monitors.concat(json.monitors);
            pageCount = json.metadata.page_count;
            page += 1;
        } while (page < pageCount);
        return monitors;
    });
}
exports.searchMonitors = searchMonitors;
function getCloudFormationStackId(serverless) {
    return __awaiter(this, void 0, void 0, function* () {
        const stackName = serverless.getProvider("aws").naming.getStackName();
        const describeStackOutput = yield serverless
            .getProvider("aws")
            .request("CloudFormation", "describeStacks", { StackName: stackName }, { region: serverless.getProvider("aws").getRegion() })
            .catch(() => {
            // Ignore any request exceptions, fail silently and skip output logging
        });
        const cloudFormationStackId = describeStackOutput ? describeStackOutput.Stacks[0].StackId : "";
        return cloudFormationStackId;
    });
}
exports.getCloudFormationStackId = getCloudFormationStackId;
function getExistingMonitors(site, cloudFormationStackId, monitorsApiKey, monitorsAppKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const existingMonitors = yield searchMonitors(site, `aws_cloudformation_stack-id:${cloudFormationStackId}`, monitorsApiKey, monitorsAppKey);
        const serverlessMonitorIdByMonitorId = {};
        for (const existingMonitor of existingMonitors) {
            for (const tag of existingMonitor.tags) {
                if (tag.startsWith("serverless_monitor_id:") || tag.startsWith("serverless_id:")) {
                    const serverlessMonitorId = tag.substring(tag.indexOf(":") + 1);
                    serverlessMonitorIdByMonitorId[serverlessMonitorId] = existingMonitor.id;
                }
            }
        }
        return serverlessMonitorIdByMonitorId;
    });
}
exports.getExistingMonitors = getExistingMonitors;
function getRecommendedMonitors(site, monitorsApiKey, monitorsAppKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const recommendedMonitors = {};
        // Setting a count of 50 in the hope that all can be fetched at once. The default is 10 per page.
        const endpoint = `https://api.${site}/api/v2/monitor/recommended?count=50&start=0&search=tag%3A%22product%3Aserverless%22%20AND%20tag%3A%22integration%3Aamazon-lambda%22`;
        const response = yield (0, node_fetch_1.default)(endpoint, {
            method: "GET",
            headers: {
                "DD-API-KEY": monitorsApiKey,
                "DD-APPLICATION-KEY": monitorsAppKey,
                "Content-Type": "application/json",
            },
        });
        if (response.status !== 200) {
            throw new Error(`Can't fetch monitor params. Status code: ${response.status}. Message: ${response.statusText}`);
        }
        const json = yield response.json();
        const recommendedMonitorsData = json.data;
        recommendedMonitorsData.forEach((recommendedMonitorParam) => {
            const recommendedMonitorId = parseRecommendedMonitorServerlessId(recommendedMonitorParam);
            if (recommendedMonitorId === undefined) {
                return;
            }
            const recommendedMonitor = {
                name: recommendedMonitorParam.attributes.name,
                threshold: recommendedMonitorParam.attributes.options.thresholds.critical,
                message: recommendedMonitorParam.attributes.message,
                type: recommendedMonitorParam.attributes.type,
                query: (cloudFormationStackId, criticalThreshold) => {
                    let query = recommendedMonitorParam.attributes.query;
                    // replace $scope with cloudformation_stack_id
                    query = query.replace(/\$scope/g, `aws_cloudformation_stack-id:${cloudFormationStackId}`);
                    if (criticalThreshold !== recommendedMonitorParam.attributes.options.thresholds.critical) {
                        query = (0, monitors_1.replaceCriticalThreshold)(query, criticalThreshold);
                    }
                    return query;
                },
                templateVariables: recommendedMonitorParam.attributes.template_variables,
            };
            recommendedMonitors[recommendedMonitorId] = recommendedMonitor;
        });
        return recommendedMonitors;
    });
}
exports.getRecommendedMonitors = getRecommendedMonitors;
function parseRecommendedMonitorServerlessId(recommendedMonitorParams) {
    for (const tag of recommendedMonitorParams.attributes.tags) {
        if (tag.startsWith("serverless_id:")) {
            return tag.substring(tag.indexOf(":") + 1);
        }
    }
    return undefined;
}
exports.parseRecommendedMonitorServerlessId = parseRecommendedMonitorServerlessId;
//# sourceMappingURL=monitor-api-requests.js.map