"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFunctionDefinitionHandler = exports.pushLayerARN = exports.applyExtensionLayer = exports.applyLambdaLibraryLayers = exports.normalizeRuntimeKey = exports.findHandlers = exports.ARM_RUNTIME_KEYS = exports.runtimeLookup = exports.RuntimeType = void 0;
var RuntimeType;
(function (RuntimeType) {
    RuntimeType["NODE"] = "node";
    RuntimeType["PYTHON"] = "python";
    RuntimeType["DOTNET"] = "dotnet";
    RuntimeType["CUSTOM"] = "custom";
    RuntimeType["JAVA"] = "java";
    RuntimeType["RUBY"] = "ruby";
    RuntimeType["GO"] = "go";
    RuntimeType["UNSUPPORTED"] = "unsupported";
})(RuntimeType = exports.RuntimeType || (exports.RuntimeType = {}));
// .NET can only be used with the extension and Java requires
// some code changes
const RUNTIMES_TO_ADD_FOR_EXTENSION_ONLY = [RuntimeType.DOTNET, RuntimeType.JAVA];
const X86_64_ARCHITECTURE = "x86_64";
const ARM64_ARCHITECTURE = "arm64";
const DEFAULT_ARCHITECTURE = X86_64_ARCHITECTURE;
const DEFAULT_REGION = "us-east-1";
exports.runtimeLookup = {
    "nodejs16.x": RuntimeType.NODE,
    "nodejs18.x": RuntimeType.NODE,
    "nodejs20.x": RuntimeType.NODE,
    "nodejs22.x": RuntimeType.NODE,
    "python3.7": RuntimeType.PYTHON,
    "python3.8": RuntimeType.PYTHON,
    "python3.9": RuntimeType.PYTHON,
    "python3.10": RuntimeType.PYTHON,
    "python3.11": RuntimeType.PYTHON,
    "python3.12": RuntimeType.PYTHON,
    "python3.13": RuntimeType.PYTHON,
    dotnet6: RuntimeType.DOTNET,
    dotnet8: RuntimeType.DOTNET,
    java11: RuntimeType.JAVA,
    java17: RuntimeType.JAVA,
    java21: RuntimeType.JAVA,
    "java8.al2": RuntimeType.JAVA,
    java8: RuntimeType.JAVA,
    "provided.al2": RuntimeType.CUSTOM,
    "provided.al2023": RuntimeType.CUSTOM,
    provided: RuntimeType.CUSTOM,
    "ruby3.2": RuntimeType.RUBY,
    "go1.x": RuntimeType.GO,
};
// Map from x86 runtime keys in layers.json to the corresponding ARM runtime keys
exports.ARM_RUNTIME_KEYS = {
    "python3.8": "python3.8-arm",
    "python3.9": "python3.9-arm",
    "python3.10": "python3.10-arm",
    "python3.11": "python3.11-arm",
    "python3.12": "python3.12-arm",
    "python3.13": "python3.13-arm",
    "ruby3.2": "ruby3.2-arm",
    extension: "extension-arm",
    dotnet: "dotnet-arm",
    // The same Node layers work for both x86 and ARM
    "nodejs16.x": "nodejs16.x",
    "nodejs18.x": "nodejs18.x",
    "nodejs20.x": "nodejs20.x",
    "nodejs22.x": "nodejs22.x",
    // The same Java layer works for both x86 and ARM
    java: "java",
};
function findHandlers(service, exclude, defaultRuntime) {
    return Object.entries(service.functions)
        .map(([name, handler]) => {
        let { runtime } = handler;
        if (runtime === undefined) {
            runtime = defaultRuntime;
        }
        if (runtime !== undefined && runtime in exports.runtimeLookup) {
            return { type: exports.runtimeLookup[runtime], runtime, name, handler };
        }
        return { type: RuntimeType.UNSUPPORTED, runtime, name, handler };
    })
        .filter((result) => result !== undefined)
        .filter((result) => exclude === undefined || (exclude !== undefined && !exclude.includes(result.name)));
}
exports.findHandlers = findHandlers;
/**
 * Normalize the runtime in the yml to match our layers.json keys
 * For most runtimes the key in layers.json is the same as the string set in the
 * serverless.yml, but for dotnet and java they are not
 *
 * @param runtimeSetting string set in serverless.yml ex: "dotnet6", "nodejs18.x"
 * @returns normalized runtime key
 */
function normalizeRuntimeKey(runtimeSetting) {
    if (runtimeSetting.startsWith("dotnet")) {
        return "dotnet";
    }
    if (runtimeSetting.startsWith("java")) {
        return "java";
    }
    return runtimeSetting;
}
exports.normalizeRuntimeKey = normalizeRuntimeKey;
/**
 * Add library layers for the given runtime and architecture
 *
 * @param service Serverless framework service
 * @param handlers Lambda functions to add layers to
 * @param layers layers.json file read into an object
 * @param accountId optional account ID that the layers live in - undefined
 *        unless the customer sets a value for useLayersFromAccount in yaml
 * @param isUsingExtension whether to install the Datadog Lambda Extension as a layer
 */
function applyLambdaLibraryLayers(service, handlers, layers, accountId, isUsingExtension = true) {
    var _a, _b, _c;
    const { region } = service.provider;
    // It's possible a local account layer is being used in a region we have not published to so we use a default region's ARNs
    const shouldUseDefaultRegion = layers.regions[region] === undefined && accountId !== undefined;
    const regionRuntimes = shouldUseDefaultRegion ? layers.regions[DEFAULT_REGION] : layers.regions[region];
    if (regionRuntimes === undefined) {
        return;
    }
    for (const handler of handlers) {
        if (handler.type === RuntimeType.UNSUPPORTED) {
            continue;
        }
        const { runtime } = handler;
        if (runtime === undefined) {
            continue;
        }
        if (!isUsingExtension && RUNTIMES_TO_ADD_FOR_EXTENSION_ONLY.includes(handler.type)) {
            continue;
        }
        const x86RuntimeKey = normalizeRuntimeKey(runtime);
        const armRuntimeKey = exports.ARM_RUNTIME_KEYS[x86RuntimeKey];
        let x86LayerArn = regionRuntimes[x86RuntimeKey];
        let armLayerArn = regionRuntimes[armRuntimeKey];
        if (accountId && x86LayerArn) {
            x86LayerArn = buildLocalLambdaLayerARN(x86LayerArn, accountId, region);
        }
        if (accountId && armLayerArn) {
            armLayerArn = buildLocalLambdaLayerARN(armLayerArn, accountId, region);
        }
        const architecture = (_c = (_b = (_a = handler.handler) === null || _a === void 0 ? void 0 : _a.architecture) !== null && _b !== void 0 ? _b : service.provider.architecture) !== null && _c !== void 0 ? _c : DEFAULT_ARCHITECTURE;
        const isArm64 = architecture === ARM64_ARCHITECTURE;
        // Use the ARM layer if customer's handler is using ARM
        let layerARN = isArm64 ? armLayerArn : x86LayerArn;
        // Fall back to the x86 layer if no ARM layer is available
        if (isArm64 && layerARN === undefined) {
            layerARN = x86LayerArn;
        }
        if (accountId && layerARN) {
            layerARN = buildLocalLambdaLayerARN(layerARN, accountId, region);
        }
        if (isArm64 && layerARN !== undefined && x86LayerArn !== undefined) {
            // Remove the x86 layer if the customer is using ARM
            removePreviousLayer(service, handler, x86LayerArn);
        }
        if (!isArm64 && layerARN !== undefined && armLayerArn !== undefined) {
            // Remove the ARM layer if the customer is using x86
            removePreviousLayer(service, handler, armLayerArn);
        }
        if (layerARN) {
            addLayer(service, handler, layerARN);
        }
    }
}
exports.applyLambdaLibraryLayers = applyLambdaLibraryLayers;
function applyExtensionLayer(service, handlers, layers, accountId) {
    var _a, _b;
    const { region } = service.provider;
    // It's possible a local account layer is being used in a region we have not published to so we use a default region's ARNs
    const shouldUseDefaultRegion = layers.regions[region] === undefined && accountId !== undefined;
    const regionRuntimes = shouldUseDefaultRegion ? layers.regions[DEFAULT_REGION] : layers.regions[region];
    if (regionRuntimes === undefined) {
        return;
    }
    for (const handler of handlers) {
        if (handler.type === RuntimeType.UNSUPPORTED) {
            continue;
        }
        const architecture = (_b = (_a = handler.handler.architecture) !== null && _a !== void 0 ? _a : service.provider.architecture) !== null && _b !== void 0 ? _b : DEFAULT_ARCHITECTURE;
        let extensionLayerKey = "extension";
        if (architecture === ARM64_ARCHITECTURE) {
            const prevExtensionARN = accountId !== undefined
                ? buildLocalLambdaLayerARN(regionRuntimes[extensionLayerKey], accountId, region)
                : regionRuntimes[extensionLayerKey];
            removePreviousLayer(service, handler, prevExtensionARN);
            extensionLayerKey = exports.ARM_RUNTIME_KEYS[extensionLayerKey];
        }
        let extensionARN = regionRuntimes[extensionLayerKey];
        if (accountId && extensionARN) {
            extensionARN = buildLocalLambdaLayerARN(extensionARN, accountId, region);
        }
        if (extensionARN) {
            addLayer(service, handler, extensionARN);
        }
    }
}
exports.applyExtensionLayer = applyExtensionLayer;
function pushLayerARN(layerARN, currentLayers) {
    const layerSet = new Set(currentLayers);
    layerSet.add(layerARN);
    return Array.from(layerSet);
}
exports.pushLayerARN = pushLayerARN;
function isFunctionDefinitionHandler(funcDef) {
    return typeof funcDef.handler === "string";
}
exports.isFunctionDefinitionHandler = isFunctionDefinitionHandler;
function addLayer(service, handler, layerArn) {
    setLayers(handler, pushLayerARN(layerArn, getLayers(service, handler)));
}
function getLayers(service, handler) {
    const functionLayersList = handler.handler.layers || [];
    const serviceLayersList = service.provider.layers || [];
    // Function-level layers override service-level layers
    // Append to the function-level layers if other function-level layers are present
    // If service-level layers are present
    // Set them at the function level, as our layers are runtime-dependent and could vary
    // between functions in the same project
    if (functionLayersList.length > 0 || serviceLayersList.length === 0) {
        return functionLayersList;
    }
    else {
        return serviceLayersList;
    }
}
function removePreviousLayer(service, handler, previousLayer) {
    let layersList = getLayers(service, handler);
    if (new Set(layersList).has(previousLayer)) {
        layersList = layersList === null || layersList === void 0 ? void 0 : layersList.filter((layer) => layer !== previousLayer);
    }
    setLayers(handler, layersList);
}
function setLayers(handler, layers) {
    handler.handler.layers = layers;
}
function buildLocalLambdaLayerARN(layerARN, accountId, region) {
    if (layerARN === undefined) {
        return;
    }
    // Rebuild the layer ARN to use the given account's region and partition
    const [layerName, layerVersion] = layerARN.split(":").slice(6, 8);
    const partition = getAwsPartitionByRegion(region);
    const localLayerARN = `arn:${partition}:lambda:${region}:${accountId}:layer:${layerName}:${layerVersion}`;
    return localLayerARN;
}
function getAwsPartitionByRegion(region) {
    if (region.startsWith("us-gov-")) {
        return "aws-us-gov";
    }
    if (region.startsWith("cn-")) {
        return "aws-cn";
    }
    return "aws";
}
//# sourceMappingURL=layer.js.map