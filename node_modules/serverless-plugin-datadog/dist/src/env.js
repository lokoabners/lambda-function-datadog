"use strict";
/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache License Version 2.0.
 *
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2021 Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasWebpackPlugin = exports.forceExcludeDepsFromWebpack = exports.getConfig = exports.setSourceCodeIntegrationEnvVar = exports.setEnvConfiguration = exports.defaultConfiguration = exports.ddTagsEnvVar = exports.ddVersionEnvVar = exports.ddEnvEnvVar = exports.ddServiceEnvVar = void 0;
const layer_1 = require("./layer");
const output_1 = require("./output");
const webpackPluginName = "serverless-webpack";
const apiKeyEnvVar = "DD_API_KEY";
const apiKeyKMSEnvVar = "DD_KMS_API_KEY";
const apiKeySecretArnEnvVar = "DD_API_KEY_SECRET_ARN";
const siteURLEnvVar = "DD_SITE";
const logLevelEnvVar = "DD_LOG_LEVEL";
const logForwardingEnvVar = "DD_FLUSH_TO_LOG";
const ddTracingEnabledEnvVar = "DD_TRACE_ENABLED";
const ddASMEnabledEnvVar = "DD_SERVERLESS_APPSEC_ENABLED";
const ddMergeXrayTracesEnvVar = "DD_MERGE_XRAY_TRACES";
const logInjectionEnvVar = "DD_LOGS_INJECTION";
const ddLogsEnabledEnvVar = "DD_SERVERLESS_LOGS_ENABLED";
const ddCaptureLambdaPayloadEnvVar = "DD_CAPTURE_LAMBDA_PAYLOAD";
const ddColdStartTracingEnabledEnvVar = "DD_COLD_START_TRACING";
const ddMinColdStartDurationEnvVar = "DD_MIN_COLD_START_DURATION";
const ddColdStartTracingSkipLibsEnvVar = "DD_COLD_START_TRACE_SKIP_LIB";
const ddProfilingEnabledEnvVar = "DD_PROFILING_ENABLED";
const ddEncodeAuthorizerContextEnvVar = "DD_ENCODE_AUTHORIZER_CONTEXT";
const ddDecodeAuthorizerContextEnvVar = "DD_DECODE_AUTHORIZER_CONTEXT";
const ddApmFlushDeadlineMillisecondsEnvVar = "DD_APM_FLUSH_DEADLINE_MILLISECONDS";
const ddUseLayersFromAccount = "DD_USE_LAYERS_FROM_ACCOUNT";
exports.ddServiceEnvVar = "DD_SERVICE";
exports.ddEnvEnvVar = "DD_ENV";
exports.ddVersionEnvVar = "DD_VERSION";
exports.ddTagsEnvVar = "DD_TAGS";
// The Universal instrumentation wrapper which configures several env variables.
// Currently it is only used for Java and .NET
const AWS_LAMBDA_EXEC_WRAPPER_VAR = "AWS_LAMBDA_EXEC_WRAPPER";
const AWS_LAMBDA_EXEC_WRAPPER = "/opt/datadog_wrapper";
exports.defaultConfiguration = {
    addLayers: true,
    flushMetricsToLogs: true,
    logLevel: undefined,
    site: "datadoghq.com",
    subdomain: "app",
    enableXrayTracing: false,
    enableDDTracing: true,
    addExtension: true,
    enableTags: true,
    injectLogContext: true,
    enableSourceCodeIntegration: true,
    uploadGitMetadata: true,
    exclude: [],
    testingMode: false,
    integrationTesting: false,
    subscribeToAccessLogs: true,
    subscribeToExecutionLogs: false,
    subscribeToStepFunctionLogs: false,
    enableDDLogs: true,
    captureLambdaPayload: false,
    failOnError: false,
    skipCloudformationOutputs: false,
    mergeStepFunctionAndLambdaTraces: false,
    propagateTraceContext: false,
    propagateUpstreamTrace: false,
    enableStepFunctionsTracing: false,
    redirectHandlers: true,
};
function setEnvConfiguration(config, handlers) {
    handlers.forEach(({ handler, type }) => {
        var _a, _b, _c, _d;
        (_a = handler.environment) !== null && _a !== void 0 ? _a : (handler.environment = {});
        const environment = handler.environment;
        const functionName = (_b = handler.name) !== null && _b !== void 0 ? _b : "";
        if (process.env.DATADOG_API_KEY !== undefined &&
            environment[apiKeyEnvVar] === undefined &&
            // Only set this from the environment if all other methods of authentication
            // are not in use. This will set DATADOG_API_KEY on the lambda from the environment
            // variable directly if they haven't set one of the below three options
            // in the configuration.
            config.apiKMSKey === undefined &&
            config.apiKey === undefined &&
            config.apiKeySecretArn === undefined) {
            environment[apiKeyEnvVar] = process.env.DATADOG_API_KEY;
            (0, output_1.logMessage)("Using DATADOG_API_KEY environment variable for authentication");
        }
        if (config.apiKey !== undefined && environment[apiKeyEnvVar] === undefined) {
            environment[apiKeyEnvVar] = config.apiKey;
        }
        if (config.apiKMSKey !== undefined && environment[apiKeyKMSEnvVar] === undefined) {
            environment[apiKeyKMSEnvVar] = config.apiKMSKey;
        }
        if (config.apiKeySecretArn !== undefined && environment[apiKeySecretArnEnvVar] === undefined) {
            const isNode = layer_1.runtimeLookup[handler.runtime] === layer_1.RuntimeType.NODE;
            const isSendingSynchronousMetrics = !config.addExtension && !config.flushMetricsToLogs;
            if (isSendingSynchronousMetrics && isNode) {
                throw new Error("`apiKeySecretArn` is not supported for Node runtimes when using Synchronous Metrics. Set DATADOG_API_KEY in your environment, or use `apiKmsKey` in the configuration.");
            }
            environment[apiKeySecretArnEnvVar] = config.apiKeySecretArn;
        }
        if (environment[siteURLEnvVar] === undefined) {
            environment[siteURLEnvVar] = config.site;
        }
        if (environment[logLevelEnvVar] === undefined) {
            environment[logLevelEnvVar] = config.logLevel;
        }
        if (environment[logForwardingEnvVar] === undefined && config.addExtension === false) {
            environment[logForwardingEnvVar] = config.flushMetricsToLogs;
        }
        if (config.enableDDTracing !== undefined && environment[ddTracingEnabledEnvVar] === undefined) {
            environment[ddTracingEnabledEnvVar] = config.enableDDTracing;
        }
        if (config.enableASM !== undefined && config.enableASM) {
            if ((config.enableASM && !config.enableDDTracing) || (config.enableASM && !config.addExtension)) {
                throw new Error("`enableASM` requires the extension to be present, and `enableDDTracing` to be enabled");
            }
            (_c = environment[AWS_LAMBDA_EXEC_WRAPPER_VAR]) !== null && _c !== void 0 ? _c : (environment[AWS_LAMBDA_EXEC_WRAPPER_VAR] = AWS_LAMBDA_EXEC_WRAPPER);
            (_d = environment[ddASMEnabledEnvVar]) !== null && _d !== void 0 ? _d : (environment[ddASMEnabledEnvVar] = config.enableASM);
        }
        if (config.enableXrayTracing !== undefined && environment[ddMergeXrayTracesEnvVar] === undefined) {
            environment[ddMergeXrayTracesEnvVar] = config.enableXrayTracing;
        }
        if (config.addExtension) {
            environment[logInjectionEnvVar] = false;
        }
        else if (config.injectLogContext !== undefined && environment[logInjectionEnvVar] === undefined) {
            environment[logInjectionEnvVar] = config.injectLogContext;
        }
        if (config.enableDDLogs !== undefined && environment[ddLogsEnabledEnvVar] === undefined) {
            environment[ddLogsEnabledEnvVar] = config.enableDDLogs;
        }
        if (environment[ddCaptureLambdaPayloadEnvVar] === undefined) {
            environment[ddCaptureLambdaPayloadEnvVar] = config.captureLambdaPayload;
        }
        if (config.enableColdStartTracing !== undefined && environment[ddColdStartTracingEnabledEnvVar] === undefined) {
            environment[ddColdStartTracingEnabledEnvVar] = config.enableColdStartTracing;
        }
        if (config.minColdStartTraceDuration !== undefined && environment[ddMinColdStartDurationEnvVar] === undefined) {
            environment[ddMinColdStartDurationEnvVar] = config.minColdStartTraceDuration;
        }
        if (config.coldStartTraceSkipLibs !== undefined && environment[ddColdStartTracingSkipLibsEnvVar] === undefined) {
            environment[ddColdStartTracingSkipLibsEnvVar] = config.coldStartTraceSkipLibs;
        }
        if (config.enableProfiling !== undefined && environment[ddProfilingEnabledEnvVar] === undefined) {
            environment[ddProfilingEnabledEnvVar] = config.enableProfiling;
        }
        if (config.encodeAuthorizerContext !== undefined && environment[ddEncodeAuthorizerContextEnvVar] === undefined) {
            environment[ddEncodeAuthorizerContextEnvVar] = config.encodeAuthorizerContext;
        }
        if (config.decodeAuthorizerContext !== undefined && environment[ddDecodeAuthorizerContextEnvVar] === undefined) {
            environment[ddDecodeAuthorizerContextEnvVar] = config.decodeAuthorizerContext;
        }
        if (config.apmFlushDeadline !== undefined && environment[ddApmFlushDeadlineMillisecondsEnvVar] === undefined) {
            environment[ddApmFlushDeadlineMillisecondsEnvVar] = config.apmFlushDeadline;
        }
        if (config.useLayersFromAccount !== undefined && environment[ddUseLayersFromAccount] === undefined) {
            environment[ddUseLayersFromAccount] = config.useLayersFromAccount;
        }
        if (type === layer_1.RuntimeType.DOTNET || type === layer_1.RuntimeType.JAVA) {
            if (environment[AWS_LAMBDA_EXEC_WRAPPER_VAR] === undefined) {
                environment[AWS_LAMBDA_EXEC_WRAPPER_VAR] = AWS_LAMBDA_EXEC_WRAPPER;
            }
            else if (environment[AWS_LAMBDA_EXEC_WRAPPER_VAR] !== AWS_LAMBDA_EXEC_WRAPPER) {
                throwEnvVariableError("AWS_LAMBDA_EXEC_WRAPPER", AWS_LAMBDA_EXEC_WRAPPER, functionName);
            }
        }
    });
}
exports.setEnvConfiguration = setEnvConfiguration;
function setSourceCodeIntegrationEnvVar(handler, gitHash, gitRemote) {
    var _a;
    (_a = handler.environment) !== null && _a !== void 0 ? _a : (handler.environment = {});
    if (handler.environment[exports.ddTagsEnvVar] !== undefined) {
        handler.environment[exports.ddTagsEnvVar] += `,`;
    }
    else {
        handler.environment[exports.ddTagsEnvVar] = "";
    }
    handler.environment[exports.ddTagsEnvVar] += `git.commit.sha:${gitHash},git.repository_url:${gitRemote}`;
}
exports.setSourceCodeIntegrationEnvVar = setSourceCodeIntegrationEnvVar;
function throwEnvVariableError(variable, value, functionName) {
    throw new Error(`Environment variable ${variable} should be set to ${value} for function ${functionName}`);
}
function getConfig(service) {
    var _a, _b, _c, _d, _e, _f;
    let custom = service.custom;
    if (custom === undefined) {
        custom = {};
    }
    let datadog = custom.datadog;
    if (datadog === undefined) {
        datadog = {};
    }
    // These values are deprecated but will supersede everything if set
    if ((_a = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _a === void 0 ? void 0 : _a.monitorsApiKey) {
        datadog.apiKey = (_c = (_b = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _b === void 0 ? void 0 : _b.monitorsApiKey) !== null && _c !== void 0 ? _c : datadog.apiKey;
    }
    if ((_d = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _d === void 0 ? void 0 : _d.monitorsAppKey) {
        datadog.appKey = (_f = (_e = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _e === void 0 ? void 0 : _e.monitorsAppKey) !== null && _f !== void 0 ? _f : datadog.appKey;
    }
    const config = Object.assign(Object.assign({}, exports.defaultConfiguration), datadog);
    return config;
}
exports.getConfig = getConfig;
function forceExcludeDepsFromWebpack(service) {
    const includeModules = getPropertyFromPath(service, ["custom", "webpack", "includeModules"]);
    if (includeModules === undefined) {
        return;
    }
    let forceExclude = includeModules.forceExclude;
    if (forceExclude === undefined) {
        forceExclude = [];
        includeModules.forceExclude = forceExclude;
    }
    if (!forceExclude.includes("datadog-lambda-js")) {
        forceExclude.push("datadog-lambda-js");
    }
    if (!forceExclude.includes("dd-trace")) {
        forceExclude.push("dd-trace");
    }
}
exports.forceExcludeDepsFromWebpack = forceExcludeDepsFromWebpack;
function getPropertyFromPath(obj, path) {
    for (const part of path) {
        let prop = obj[part];
        if (prop === undefined || prop === true) {
            prop = {};
            obj[part] = prop;
        }
        if (prop === false) {
            return;
        }
        obj = prop;
    }
    return obj;
}
function hasWebpackPlugin(service) {
    const plugins = service.plugins;
    if (plugins === undefined) {
        return false;
    }
    if (Array.isArray(plugins)) {
        // We have a normal plugin array
        return plugins.find((plugin) => plugin === webpackPluginName) !== undefined;
    }
    // We have an enhanced plugins object
    const modules = service.plugins.modules;
    if (modules === undefined) {
        return false;
    }
    return modules.find((plugin) => plugin === webpackPluginName) !== undefined;
}
exports.hasWebpackPlugin = hasWebpackPlugin;
//# sourceMappingURL=env.js.map