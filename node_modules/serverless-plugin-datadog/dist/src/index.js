"use strict";
/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache License Version 2.0.
 *
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2021 Datadog, Inc.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const package_json_1 = require("../package.json");
const datadog_ci_1 = require("@datadog/datadog-ci");
const env_1 = require("./env");
const forwarder_1 = require("./forwarder");
const git_1 = require("./git");
const layer_1 = require("./layer");
const govLayers = __importStar(require("./layers-gov.json"));
const layers = __importStar(require("./layers.json"));
const monitor_api_requests_1 = require("./monitor-api-requests");
const monitors_1 = require("./monitors");
const output_1 = require("./output");
const tracing_1 = require("./tracing");
const wrapper_1 = require("./wrapper");
const span_link_1 = require("./span-link");
const step_functions_helper_1 = require("./step-functions-helper");
var TagKeys;
(function (TagKeys) {
    TagKeys["Service"] = "service";
    TagKeys["Env"] = "env";
    TagKeys["Version"] = "version";
    TagKeys["Plugin"] = "dd_sls_plugin";
})(TagKeys || (TagKeys = {}));
module.exports = class ServerlessPlugin {
    constructor(serverless, options) {
        this.serverless = serverless;
        this.options = options;
        this.hooks = {
            initialize: this.cliSharedInitialize.bind(this),
            "after:datadog:clean:init": this.afterPackageFunction.bind(this),
            "after:datadog:generate:init": this.beforePackageFunction.bind(this),
            "after:deploy:function:packageFunction": this.afterPackageFunction.bind(this),
            "after:package:createDeploymentArtifacts": this.afterPackageFunction.bind(this),
            "before:package:createDeploymentArtifacts": this.beforePackageFunction.bind(this),
            "after:package:compileFunctions": this.afterPackageCompileFunctions.bind(this),
            "before:deploy:function:packageFunction": this.beforePackageFunction.bind(this),
            "before:offline:start:init": this.beforePackageFunction.bind(this),
            "before:step-functions-offline:start": this.beforePackageFunction.bind(this),
            "after:deploy:deploy": this.afterDeploy.bind(this),
            "before:package:finalize": this.afterPackageFunction.bind(this),
        };
        this.commands = {
            datadog: {
                commands: {
                    clean: {
                        lifecycleEvents: ["init"],
                        usage: "Cleans up wrapper handler functions for DataDog, not necessary in most cases",
                    },
                    generate: {
                        lifecycleEvents: ["init"],
                        usage: "Generates wrapper handler functions for DataDog, not necessary in most cases",
                    },
                },
                lifecycleEvents: ["clean", "generate"],
                usage: "Automatically instruments your lambdas with DataDog",
            },
        };
        this.displayedMessages = {};
    }
    logToCliOnce(message) {
        if (this.displayedMessages[message] === undefined) {
            this.displayedMessages[message] = true;
            this.serverless.cli.log(message);
        }
    }
    cliSharedInitialize() {
        if (this.options.function) {
            this.serverless.cli.log("Warning: Using serverless deploy -f option only updates the function code and will not update CloudFormation stack (env variables included).");
        }
    }
    beforePackageFunction() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = (0, env_1.getConfig)(this.serverless.service);
            if (config.enabled === false)
                return;
            this.serverless.cli.log("Auto instrumenting functions with Datadog");
            configHasOldProperties(config);
            if (config.monitorsApiKey !== undefined || config.monitorsAppKey !== undefined) {
                this.serverless.cli.log("Warning: `monitorsApiKey` and `monitorsAppKey` have been deprecated. Please set DATADOG_API_KEY and DATADOG_APP_KEY in your environment instead.");
            }
            validateConfiguration(config);
            const defaultRuntime = this.serverless.service.provider.runtime;
            const handlers = (0, layer_1.findHandlers)(this.serverless.service, config.exclude, defaultRuntime);
            (0, env_1.setEnvConfiguration)(config, handlers);
            const allLayers = { regions: Object.assign(Object.assign({}, layers.regions), govLayers.regions) };
            const accountId = config.useLayersFromAccount;
            if (config.addLayers) {
                this.serverless.cli.log("Adding Lambda Library Layers to functions");
                this.debugLogHandlers(handlers);
                (0, layer_1.applyLambdaLibraryLayers)(this.serverless.service, handlers, allLayers, accountId, config.addExtension);
                if ((0, env_1.hasWebpackPlugin)(this.serverless.service)) {
                    (0, env_1.forceExcludeDepsFromWebpack)(this.serverless.service);
                }
            }
            else {
                this.serverless.cli.log("Skipping adding Lambda Library Layers, make sure you are packaging them yourself");
            }
            if (config.addExtension) {
                this.serverless.cli.log("Adding Datadog Lambda Extension Layer to functions");
                this.debugLogHandlers(handlers);
                (0, layer_1.applyExtensionLayer)(this.serverless.service, handlers, allLayers, accountId);
            }
            else {
                this.serverless.cli.log("Skipping adding Lambda Extension Layer");
            }
            if (config.addExtension) {
                this.serverless.cli.log("Adding Datadog Env Vars");
                this.addDDEnvVars(handlers);
            }
            else {
                this.addDDTagsForLambda(handlers);
            }
            let tracingMode = tracing_1.TracingMode.NONE;
            if (config.enableXrayTracing && config.enableDDTracing) {
                tracingMode = tracing_1.TracingMode.HYBRID;
            }
            else if (config.enableDDTracing) {
                tracingMode = tracing_1.TracingMode.DD_TRACE;
            }
            else if (config.enableXrayTracing) {
                tracingMode = tracing_1.TracingMode.XRAY;
            }
            (0, tracing_1.enableTracing)(this.serverless.service, tracingMode, handlers);
        });
    }
    afterPackageCompileFunctions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // State machines' "Properties" field will not be added until "after:package:compileFunctions"
            // hook. So we are updating Properties.Tag at this hook
            const resources = (_a = this.serverless.service.provider.compiledCloudFormationTemplate) === null || _a === void 0 ? void 0 : _a.Resources;
            const config = (0, env_1.getConfig)(this.serverless.service);
            for (const [_, stateMachineObj] of Object.entries(resources)) {
                if (stateMachineObj.Type && stateMachineObj.Type === "AWS::StepFunctions::StateMachine") {
                    if (stateMachineObj && stateMachineObj.Properties && !stateMachineObj.Properties.Tags) {
                        stateMachineObj.Properties.Tags = [];
                    }
                    (0, forwarder_1.addDdSlsPluginTag)(stateMachineObj); // obj is a state machine object
                    (0, forwarder_1.addDdTraceEnabledTag)(stateMachineObj, config.enableStepFunctionsTracing);
                    this.addTagsForStateMachine(stateMachineObj);
                }
            }
        });
    }
    afterPackageFunction() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const config = (0, env_1.getConfig)(this.serverless.service);
            if (config.enabled === false)
                return;
            // Create an object that contains some of our booleans for the forwarder
            const forwarderConfigs = {
                AddExtension: config.addExtension,
                TestingMode: config.testingMode,
                IntegrationTesting: config.integrationTesting,
                SubToAccessLogGroups: config.subscribeToAccessLogs,
                SubToExecutionLogGroups: config.subscribeToExecutionLogs,
                SubToStepFunctionLogGroups: config.subscribeToStepFunctionLogs,
            };
            const defaultRuntime = this.serverless.service.provider.runtime;
            const handlers = (0, layer_1.findHandlers)(this.serverless.service, config.exclude, defaultRuntime);
            let datadogForwarderArn;
            datadogForwarderArn = this.extractDatadogForwarder(config);
            if (datadogForwarderArn) {
                const aws = this.serverless.getProvider("aws");
                const errors = yield (0, forwarder_1.addCloudWatchForwarderSubscriptions)(this.serverless.service, aws, datadogForwarderArn, forwarderConfigs, handlers);
                if (config.subscribeToExecutionLogs) {
                    yield (0, forwarder_1.addExecutionLogGroupsAndSubscriptions)(this.serverless.service, aws, datadogForwarderArn);
                }
                yield this.instrumentStepFunctions(config, aws, datadogForwarderArn);
                for (const error of errors) {
                    this.serverless.cli.log(error);
                }
            }
            if (datadogForwarderArn && config.addExtension) {
                this.serverless.cli.log(`Warning: Datadog Lambda Extension and forwarder are both enabled. Only APIGateway ${config.subscribeToStepFunctionLogs ? "and Step Function " : ""}log groups will be subscribed to the forwarder.`);
            }
            this.addTags(handlers, config.addExtension !== true);
            if (config.enableSourceCodeIntegration) {
                this.logToCliOnce(`Adding source code integration`);
                if (((_a = process.env.DATADOG_API_KEY) !== null && _a !== void 0 ? _a : config.apiKey) === undefined) {
                    let keyError;
                    if (config.apiKeySecretArn) {
                        keyError = "encrypted credentials through KMS/Secrets Manager is not supported for this integration";
                    }
                    else {
                        keyError = "Datadog credentials were not found";
                    }
                    this.logToCliOnce(`Skipping enabling source code integration because ${keyError}. Please set either DATADOG_API_KEY in your environment, or set the apiKey parameter in Serverless.`);
                }
                else {
                    const simpleGit = yield (0, git_1.newSimpleGit)();
                    if (simpleGit !== undefined && (yield simpleGit.checkIsRepo())) {
                        try {
                            const [gitRemote, gitHash] = yield datadog_ci_1.gitMetadata.getGitCommitInfo();
                            handlers.forEach(({ handler }) => {
                                (0, env_1.setSourceCodeIntegrationEnvVar)(handler, gitHash, gitRemote);
                            });
                            if (config.uploadGitMetadata) {
                                this.logToCliOnce(`Uploading git metadata`);
                                yield datadog_ci_1.gitMetadata.uploadGitCommitHash(((_b = process.env.DATADOG_API_KEY) !== null && _b !== void 0 ? _b : config.apiKey), config.site);
                            }
                        }
                        catch (err) {
                            this.logToCliOnce(`Error occurred when adding source code integration: ${err}`);
                        }
                    }
                }
            }
            // defaults to true
            if (config.redirectHandlers) {
                (0, wrapper_1.redirectHandlers)(handlers, config.addLayers, config.customHandler);
            }
            if ((config.testingMode === false || config.integrationTesting === false) &&
                config.skipCloudformationOutputs === false) {
                yield (0, output_1.addOutputLinks)(this.serverless, config.site, config.subdomain, handlers);
            }
            else {
                this.serverless.cli.log("Skipped adding output links");
            }
        });
    }
    /**
     * Do the major part of the work for instrumenting step functions.
     * This function does not set tags. That is done in afterPackageCompileFunctions().
     */
    instrumentStepFunctions(config, aws, datadogForwarderArn) {
        return __awaiter(this, void 0, void 0, function* () {
            const compiledCfnTemplate = this.serverless.service.provider.compiledCloudFormationTemplate;
            // Compiled CloudFormation template may be unavailable if the user only deploys part of the stack.
            // See https://github.com/DataDog/serverless-plugin-datadog/issues/593
            // In that case, skip instrumenting step functions.
            if (!compiledCfnTemplate) {
                this.serverless.cli.log(`Compiled CloudFormation template not found. Skipping instrumenting step functions.
This is expected if you only deploy part of the stack.`);
                return;
            }
            if (config.enableStepFunctionsTracing || config.subscribeToStepFunctionLogs) {
                const resources = compiledCfnTemplate.Resources;
                const stepFunctions = Object.values(this.serverless.service.stepFunctions.stateMachines);
                if (stepFunctions.length === 0) {
                    this.serverless.cli.log("subscribeToStepFunctionLogs is set to true but no step functions were found.");
                }
                else {
                    this.serverless.cli.log("Subscribing step function log groups to Datadog Forwarder");
                    for (const stepFunction of stepFunctions) {
                        if (!stepFunction.hasOwnProperty("loggingConfig")) {
                            this.serverless.cli.log(`Creating log group for ${stepFunction.name} and logging to it with level ALL.`);
                            yield (0, forwarder_1.addStepFunctionLogGroup)(aws, resources, stepFunction);
                        }
                        else {
                            this.serverless.cli.log(`Found logging config for step function ${stepFunction.name}`);
                            const loggingConfig = stepFunction.loggingConfig;
                            if (loggingConfig.level !== "ALL") {
                                loggingConfig.level = "ALL";
                                this.serverless.cli.log(`Warning: Setting log level to ALL for step function ${stepFunction.name} so traces can be generated.`);
                            }
                            if (loggingConfig.includeExecutionData !== true) {
                                loggingConfig.includeExecutionData = true;
                                this.serverless.cli.log(`Warning: Setting includeExecutionData to true for step function ${stepFunction.name} so traces can be generated.`);
                            }
                        }
                        // subscribe step function log group to datadog forwarder regardless of how the log group was created
                        yield (0, forwarder_1.addStepFunctionLogGroupSubscription)(resources, stepFunction, datadogForwarderArn);
                    }
                }
                if (config.mergeStepFunctionAndLambdaTraces || config.propagateTraceContext) {
                    this.serverless.cli.log(`mergeStepFunctionAndLambdaTraces and propagateTraceContext will be deprecated. Please use propagateUpstreamTrace instead`);
                }
                if (config.mergeStepFunctionAndLambdaTraces || config.propagateTraceContext || config.propagateUpstreamTrace) {
                    this.serverless.cli.log(`mergeStepFunctionAndLambdaTraces or propagateUpstreamTrace is true, trying to modify Step Functions' definitions to add trace context.`);
                    (0, span_link_1.mergeStepFunctionAndLambdaTraces)(resources, this.serverless);
                }
            }
            else {
                // Recommend Step Functions instrumentation for customers who do not set enableStepFunctionsTracing to true
                try {
                    (0, step_functions_helper_1.inspectAndRecommendStepFunctionsInstrumentation)(this.serverless);
                }
                catch (error) {
                    this.serverless.cli.log(`Error raise when inspecting if there are any uninstrumented Step Functions state machines. Error: ${error}`);
                }
            }
        });
    }
    afterDeploy() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        return __awaiter(this, void 0, void 0, function* () {
            const config = (0, env_1.getConfig)(this.serverless.service);
            const custom = ((_a = this.serverless.service.custom) !== null && _a !== void 0 ? _a : {});
            const service = (_c = (_b = custom.datadog) === null || _b === void 0 ? void 0 : _b.service) !== null && _c !== void 0 ? _c : this.serverless.service.getServiceName();
            const env = (_e = (_d = custom.datadog) === null || _d === void 0 ? void 0 : _d.env) !== null && _e !== void 0 ? _e : this.serverless.getProvider("aws").getStage();
            if (config.enabled === false)
                return;
            if (config.monitors &&
                ((_f = config.apiKey) !== null && _f !== void 0 ? _f : process.env.DATADOG_API_KEY) &&
                ((_g = config.appKey) !== null && _g !== void 0 ? _g : process.env.DATADOG_APP_KEY)) {
                const cloudFormationStackId = yield (0, monitor_api_requests_1.getCloudFormationStackId)(this.serverless);
                try {
                    const logStatements = yield (0, monitors_1.setMonitors)(config.subdomain, config.site, config.monitors, ((_h = config.apiKey) !== null && _h !== void 0 ? _h : process.env.DATADOG_API_KEY), ((_j = config.appKey) !== null && _j !== void 0 ? _j : process.env.DATADOG_APP_KEY), cloudFormationStackId, service, env);
                    for (const logStatement of logStatements) {
                        this.serverless.cli.log(logStatement);
                    }
                }
                catch (err) {
                    if (err instanceof Error) {
                        this.serverless.cli.log(`Error occurred when configuring monitors: ${err.message}`);
                        if (config.failOnError) {
                            throw err;
                        }
                    }
                }
            }
            return (0, output_1.printOutputs)(this.serverless, config.site, config.subdomain, service, env);
        });
    }
    debugLogHandlers(handlers) {
        for (const handler of handlers) {
            if (handler.type === layer_1.RuntimeType.UNSUPPORTED) {
                if (handler.runtime === undefined) {
                    this.serverless.cli.log(`Unable to determine runtime for function ${handler.name}`);
                }
                else {
                    this.serverless.cli.log(`Unable to add Lambda Layers to function ${handler.name} with runtime ${handler.runtime}`);
                }
            }
        }
    }
    /**
     * Check for service, env, version, and additional tags at the custom level.
     * If these don't already exsist on the function level as env vars, adds them as DD_XXX env vars
     */
    addDDEnvVars(handlers) {
        const provider = this.serverless.service.provider;
        const service = this.serverless.service;
        let custom = service.custom;
        if (custom === undefined) {
            custom = {};
        }
        handlers.forEach(({ handler }) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
            (_a = handler.environment) !== null && _a !== void 0 ? _a : (handler.environment = {});
            const environment = handler.environment;
            (_b = provider.environment) !== null && _b !== void 0 ? _b : (provider.environment = {});
            const providerEnvironment = provider.environment;
            if ((_c = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _c === void 0 ? void 0 : _c.service) {
                (_d = environment[env_1.ddServiceEnvVar]) !== null && _d !== void 0 ? _d : (environment[env_1.ddServiceEnvVar] = (_e = providerEnvironment[env_1.ddServiceEnvVar]) !== null && _e !== void 0 ? _e : custom.datadog.service);
            }
            if ((_f = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _f === void 0 ? void 0 : _f.env) {
                (_g = environment[env_1.ddEnvEnvVar]) !== null && _g !== void 0 ? _g : (environment[env_1.ddEnvEnvVar] = (_h = providerEnvironment[env_1.ddEnvEnvVar]) !== null && _h !== void 0 ? _h : custom.datadog.env);
            }
            if ((_j = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _j === void 0 ? void 0 : _j.version) {
                (_k = environment[env_1.ddVersionEnvVar]) !== null && _k !== void 0 ? _k : (environment[env_1.ddVersionEnvVar] = (_l = providerEnvironment[env_1.ddVersionEnvVar]) !== null && _l !== void 0 ? _l : custom.datadog.version);
            }
            if ((_m = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _m === void 0 ? void 0 : _m.tags) {
                (_o = environment[env_1.ddTagsEnvVar]) !== null && _o !== void 0 ? _o : (environment[env_1.ddTagsEnvVar] = (_p = providerEnvironment[env_1.ddTagsEnvVar]) !== null && _p !== void 0 ? _p : custom.datadog.tags);
            }
            // default to service and stage if env vars aren't set
            (_q = environment[env_1.ddServiceEnvVar]) !== null && _q !== void 0 ? _q : (environment[env_1.ddServiceEnvVar] = service.getServiceName());
            (_r = environment[env_1.ddEnvEnvVar]) !== null && _r !== void 0 ? _r : (environment[env_1.ddEnvEnvVar] = this.serverless.getProvider("aws").getStage());
        });
    }
    /**
     * Check for service, env, version, and additional tags at the custom level.
     * If these tags don't already exist on the function level, adds them as tags
     */
    addDDTagsForLambda(handlers) {
        const service = this.serverless.service;
        let custom = service.custom;
        if (custom === undefined) {
            custom = {};
        }
        handlers.forEach(({ handler }) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            var _j, _k, _l;
            (_a = handler.tags) !== null && _a !== void 0 ? _a : (handler.tags = {});
            const tags = handler.tags;
            if ((_b = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _b === void 0 ? void 0 : _b.service) {
                (_c = tags[_j = TagKeys.Service]) !== null && _c !== void 0 ? _c : (tags[_j] = custom.datadog.service);
            }
            if ((_d = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _d === void 0 ? void 0 : _d.env) {
                (_e = tags[_k = TagKeys.Env]) !== null && _e !== void 0 ? _e : (tags[_k] = custom.datadog.env);
            }
            if ((_f = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _f === void 0 ? void 0 : _f.version) {
                (_g = tags[_l = TagKeys.Version]) !== null && _g !== void 0 ? _g : (tags[_l] = custom.datadog.version);
            }
            if ((_h = custom === null || custom === void 0 ? void 0 : custom.datadog) === null || _h === void 0 ? void 0 : _h.tags) {
                const tagsArray = custom.datadog.tags.split(",");
                tagsArray.forEach((tag) => {
                    var _a;
                    const [key, value] = tag.split(":");
                    if (key && value) {
                        (_a = tags[key]) !== null && _a !== void 0 ? _a : (tags[key] = value);
                    }
                });
            }
        });
    }
    /**
     * Check for service, env, version, and additional tags at the custom level.
     * If these don't already exist on the state machine level, add them.
     */
    addTagsForStateMachine(stateMachine) {
        var _a, _b, _c;
        var _d;
        const service = this.serverless.service;
        const datadog = (_a = service.custom) === null || _a === void 0 ? void 0 : _a.datadog;
        if (datadog === undefined) {
            return;
        }
        (_b = stateMachine.Properties) !== null && _b !== void 0 ? _b : (stateMachine.Properties = {});
        (_c = (_d = stateMachine.Properties).Tags) !== null && _c !== void 0 ? _c : (_d.Tags = {});
        const tags = stateMachine.Properties.Tags;
        if (datadog.service && !tags.hasOwnProperty(TagKeys.Service)) {
            tags.push({
                Key: TagKeys.Service,
                Value: datadog.service,
            });
        }
        if (datadog.env && !tags.hasOwnProperty(TagKeys.Env)) {
            tags.push({
                Key: TagKeys.Env,
                Value: datadog.env,
            });
        }
        if (datadog.version && !tags.hasOwnProperty(TagKeys.Version)) {
            tags.push({
                Key: TagKeys.Version,
                Value: datadog.version,
            });
        }
        if (datadog.tags) {
            const tagsArray = datadog.tags.split(",");
            tagsArray.forEach((tag) => {
                const [key, value] = tag.split(":");
                if (key && value && !tags.hasOwnProperty(key)) {
                    tags.push({
                        Key: key,
                        Value: value,
                    });
                }
            });
        }
    }
    /**
     * Check for service and env tags on provider level (under tags and stackTags),
     * as well as function level. Automatically create tags for service and env with
     * properties from deployment configurations if needed; does not override any existing values.
     */
    addTags(handlers, shouldAddTags) {
        const provider = this.serverless.service.provider;
        this.logToCliOnce(`Adding Plugin Version ${package_json_1.version} tag`);
        if (shouldAddTags) {
            this.logToCliOnce(`Adding service and environment tags`);
        }
        handlers.forEach(({ handler }) => {
            var _a, _b, _c, _d, _e, _f, _g;
            var _h, _j, _k, _l;
            (_a = handler.tags) !== null && _a !== void 0 ? _a : (handler.tags = {});
            handler.tags[TagKeys.Plugin] = `v${package_json_1.version}`;
            if (shouldAddTags) {
                if (!((_b = provider.tags) === null || _b === void 0 ? void 0 : _b[TagKeys.Service]) && !((_c = provider.stackTags) === null || _c === void 0 ? void 0 : _c[TagKeys.Service])) {
                    (_d = (_h = handler.tags)[_j = TagKeys.Service]) !== null && _d !== void 0 ? _d : (_h[_j] = this.serverless.service.getServiceName());
                }
                if (!((_e = provider.tags) === null || _e === void 0 ? void 0 : _e[TagKeys.Env]) && !((_f = provider.stackTags) === null || _f === void 0 ? void 0 : _f[TagKeys.Env])) {
                    (_g = (_k = handler.tags)[_l = TagKeys.Env]) !== null && _g !== void 0 ? _g : (_k[_l] = this.serverless.getProvider("aws").getStage());
                }
            }
        });
    }
    extractDatadogForwarder(config) {
        const forwarderArn = config.forwarderArn;
        const forwarder = config.forwarder;
        if (forwarderArn && forwarder) {
            throw new Error("Both 'forwarderArn' and 'forwarder' parameters are set. Please only use the 'forwarderArn' parameter.");
        }
        else if (forwarderArn !== undefined && forwarder === undefined) {
            this.serverless.cli.log("Setting Datadog Forwarder");
            return forwarderArn;
        }
        else if (forwarder !== undefined && forwarderArn === undefined) {
            this.serverless.cli.log("Setting Datadog Forwarder");
            return forwarder;
        }
    }
};
function configHasOldProperties(obj) {
    let hasOldProperties = false;
    let message = "The following configuration options have been removed:";
    if (obj.subscribeToApiGatewayLogs) {
        message += " subscribeToApiGatewayLogs";
        hasOldProperties = true;
    }
    if (obj.subscribeToHttpApiLogs) {
        message += " subscribeToHttpApiLogs";
        hasOldProperties = true;
    }
    if (obj.subscribeToWebsocketLogs) {
        message += " subscribeToWebsocketLogs";
        hasOldProperties = true;
    }
    if (hasOldProperties) {
        throw new Error(message + ". Please use the subscribeToAccessLogs or subscribeToExecutionLogs options instead.");
    }
}
function validateConfiguration(config) {
    checkForMultipleApiKeys(config);
    const siteList = [
        "datadoghq.com",
        "datadoghq.eu",
        "us3.datadoghq.com",
        "us5.datadoghq.com",
        "ap1.datadoghq.com",
        "ddog-gov.com",
    ];
    if (!config.testingMode && config.site !== undefined && !siteList.includes(config.site.toLowerCase())) {
        throw new Error("Warning: Invalid site URL. Must be either datadoghq.com, datadoghq.eu, us3.datadoghq.com, us5.datadoghq.com, ap1.datadoghq.com, or ddog-gov.com.");
    }
    if (config.addExtension) {
        if (config.apiKey === undefined &&
            process.env.DATADOG_API_KEY === undefined &&
            config.apiKMSKey === undefined &&
            config.apiKeySecretArn === undefined) {
            throw new Error("The environment variable `DATADOG_API_KEY` or configuration variable `apiKMSKey` or `apiKeySecretArn` must be set because `addExtension` is set to true as default.");
        }
    }
    if (config.monitors) {
        if ((process.env.DATADOG_API_KEY === undefined || process.env.DATADOG_APP_KEY === undefined) &&
            // Support deprecated monitorsApiKey and monitorsAppKey
            (config.apiKey === undefined || config.appKey === undefined) &&
            (config.testingMode === false || config.integrationTesting === false)) {
            throw new Error("When `monitors` is enabled, `DATADOG_API_KEY` and `DATADOG_APP_KEY` environment variables must be set.");
        }
    }
}
function checkForMultipleApiKeys(config) {
    let multipleApiKeysMessage;
    if (config.apiKey !== undefined && config.apiKMSKey !== undefined && config.apiKeySecretArn !== undefined) {
        multipleApiKeysMessage = "`apiKey`, `apiKMSKey`, and `apiKeySecretArn`";
    }
    else if (config.apiKey !== undefined && config.apiKMSKey !== undefined) {
        multipleApiKeysMessage = "`apiKey` and `apiKMSKey`";
    }
    else if (config.apiKey !== undefined && config.apiKeySecretArn !== undefined) {
        multipleApiKeysMessage = "`apiKey` and `apiKeySecretArn`";
    }
    else if (config.apiKMSKey !== undefined && config.apiKeySecretArn !== undefined) {
        multipleApiKeysMessage = "`apiKMSKey` and `apiKeySecretArn`";
    }
    if (multipleApiKeysMessage) {
        throw new Error(`${multipleApiKeysMessage} should not be set at the same time.`);
    }
}
//# sourceMappingURL=index.js.map